# Baleen_SNR_Tool
## Work in progress  
Developed by Wilfried Beslin and Mike Adams  
Maritimes Team Whale
-------------------
Goal: An SNR tool for use in cetacean research

## Introduction
This tool is for use in calculating the signal to noise (SNR) for cetacean vocalizations obtained using JASCO's PAMLAB annotation software.
Initial development was focused on Blue Whale audible calls. The tool currently exists as a helper script<sup>*</sup> with several underlying functions. The helper script (`Baleen_SNR_Tool`) imports the output of JASCO's PAMLAB annotation files, extracts the needed inputs, and then matches the annotated calls to and imports the appropriate .wav files. These inputs are passed to the underlying functions, the first (`snr.extractSN`) to extract the data within the .wav files that corresponds to the annotated call and a sample of noise taken some time before the call. These clippings are bandpassed to the frequencies of interest using a Kaiser window-based FIR filter. Filtering is performed within `snr.extractSN` using the `snr.noDelayFilt` function, which applies the filter such that no time delays are introduced in the output. After bandpass filtering, precise start and end times of the signal are determined based on a user-specified percentage of the energy within the signal window using the function `snr.calcEng`. Noise samples are isolated relative to the energy-based start time of the signal. Ideal duration of the noise window may either be set by the user to some common value (e.g., 10 secs), or be made equal to the signal duration. If a noise window happens to includes parts of other signals that were annotated in PAMLAB, then those parts will be eliminated from the noise window (thereby shortening the noise window). The clipped and bandpassed call and noise samples are then passed to the function `snr.calculateSNR` to calculate the SNR value. The final SNR value is then appended to JASCO's PAMLAB annotation dataframe.

<sup>*</sup>_The helper script is actually implemented as a function that can optionally accept input arguments for greater flexibility. This will be discussed further in the "Usage" section below_.

## Set up

### Initial Start Up
1) Either clone or download the .zip and unzip the SNR_Tool_Development repository to your local machine.
2) Add this new directory with all of its subfolders to your MATLAB path.
### Requirements

The tool requires inputs to calculate the SNR values. These include:
  -  SNR_PARAMS.csv: a parameter file which contains the filtering and noise presets for each specie's call type. This file has values for:
      - **Species** - The species of interest (e.g. Blue Whale)
      - **Call_Type** - The call type (e.g. Audible, Tonal, etc...) 
      - **Lower_Passband_Frequency** - Lower bound of the bandpass filter before which frequencies become attenuated (Hz). This value should correspond to the lowest frequency of interest.
      - **Upper_Passband_Frequency** - Upper bound of the bandpass filter before which frequencies become attenuated (Hz). This value should correspond to the highest frequency of interest.
      - **Stopband_Rolloff_Bandwidth** - The amount of frequency bandwidth that it takes for the passband frequencies to be attenuated to a level of 60 dB (Hz). The closer this value is to zero, the sharper the passband frequency cutoffs will be, but at the expense of increased filter order (and thus processing time/memory usage). Note that filter order also increases with sampling rate.
      - **Noise_Distance** - Value to determine how far before the ***signal*** the ***noise*** sample will be taken
      - **Ideal_Noise_Duration** - The target duration that the noise window should have (seconds). This parameter can also be left empty, in which case the target noise duration will be equal to the signal duration. Note that the actual noise duration may be shorter than ideal, if the noise window contains other signals that must be removed to avoid contaminated noise estimates.
      - **Signal_Energy_Percent** - The percentage of energy within a signal window that determines the start and stop times of a signal based on cumulative energy. For example, a value of 90 will mark the start time at 5% of the cumulative energy in the window, and the stop time at 95%.
- A directory containing the .csv artefacts output generated by JASCO's PAMLAB. These files contain the artefact output of the manually selected calls. The inputs used from these files are:
  - **Filename** - used to identify the original .wav file containing the call
  - **Relative Start Time** - The manually selected start time in seconds of the call artefact relative to the start of the .wav file
- A directory containing all the .wav files for which PAMLAB artefact .csv files exist. *Note: This directory can contain additional .wav files, but **must** contain all .wav files for which PAMLAB annotations exist*   

## Running the Tool
### Basic Usage
To use the tool, open MATLAB and run the file _Baleen_SNR_Tool.m_. The most basic way to run this file is by pressing the "Run" button in the MATLAB editor, or by typing `Baleen_SNR_Tool` in the Command Window. This will load the parameters in the file _SNR_PARAMS.csv_, and you will be prompted to set the input and output file paths.

When running, the tool will also prompt the user to specify which species and call type to analyze. This dictates which row of the parameter file will be read. ***For each run of the SNR tool, all annotations in a CSV file will be processed using the species and call type that were specified by the user at runtime; the tool does not interpret species or call type information within the annotation files themselves.***

### Input Arguments
It is possible to pass certain input arguments when calling _Baleen_SNR_Tool_ via the command window, and avoid having to set them manually or use defaults. The supported arguments are:
  - **PAMLAB_DATA_FOLDER** - Path to a folder with PAMlab output. If not specified, the tool will prompt the user to select the path manually.
  - **WAV_FILE_FOLDER** - Path to the folder containing WAV files for the dataset of interest. If not specified, the tool will prompt the user to select the path manually.
  - **OUTPUT_FOLDER_LOCATION** - Path where the tool's output folder will be created (the output folder will be called _SNR_OPUTPUT_). If not specified, the tool will prompt the user to select the path manually, or simply use the parent folder of the PAMlab data if the user cancels the prompt.
  - **PARAMFILE** - Path to a CSV file of SNR parameters, as an alternative to the default _SNR_PARAMS.csv_ file. The specified file must still have the same column format as _SNR_PARAMS.csv_.

Input arguments are set by using MATLAB's Name-Value pair syntax. For example:
```matlab
Baleen_SNR_Tool('PAMLAB_DATA_FOLDER',data_dir, 'WAV_FILE_FOLDER',wav_dir)
```
where in this case, `data_dir` and `wav_dir` are char string variables specifying the paths to the PAMLAB data folder and WAV file folder, respectively (e.g., `data_dir = 'C:\Users\Me\SNR_Tool_analysis\PAMLAB'`).

### Output Arguments
_Baleen_SNR_Tool_ will always save its output as CSV files within a folder called _SNR_OUTPUT_. However, it is also possible to pass the output into the MATLAB workspace by requesting it as an output variable when running the tool. The syntax for this is:
```matlab
out = Baleen_SNR_Tool
```
where `out` is the variable that will contain the output (it does not have to be called _out_ necessarily; give it any name you want). The output variable comes in the form of a MATLAB struct containing tables of PAMLAB annotations with the SNR data appended. Each field of the struct corresponds to one PAMLAB CSV file that was processed.

## Output File [WIP]
As the tool processes each PAMLAB annotation CSV file it finds, it will create enhanced duplicates of those files that contain the SNR information appended as new columns. Those files will be saved in the folder _SNR_OUTPUT_, whose location is set by the user.

The added SNR columns are as follows:
  - **SNR_Direct** - The "raw" SNR value in dB re. noise (see "SNR Calculation"), calculated simply as:
  ```matlab
  SNR_Direct = 10*log10(powSig/powNoise)
  ```
  where `powSig` is the average power within the energy-based signal duration window, and `powNoise` is the average power within the preceding noise window (excluding samples that contain other annotated signals).
  - **SNR_Corrected** - The SNR value (in dB re. noise) corrected for noise within the signal window (see "SNR Calculation"). This value is calculated as:
  ```matlab
  SNR_Corrected = 10*log10((powSig - powNoise)/powNoise)
  ```
  where `powSig` and `powNoise` are as for _SNR_Direct_.
  - **SNRCalc_SignalDuration** - Duration of the signal as determined based on a user-specified percentage of the total energy within the signal annotation box, in seconds.
  - **SNRCalc_NoiseDuration** - Actual duration of the noise clip that was used to calculate SNR. Will always be equal to or less than the ideal noise duration, depending on whether the noise window contained other signals that needed to be removed or not.

## SNR Calculation [WIP]
The tool calculates signal-to-noise ratios as follows:
$$SNR = 10\log_{10}\left(\frac{P_{signal}}{P_{noise}}\right)$$
where $P_{signal}$ and $P_{noise}$ are the average power of signal and noise, respectively. Average power for a sampled time series $x$ is calculated as:
$$P = \frac{1}{N}\displaystyle\sum_{i=1}^{N} x_{i}^{2}$$
where $N$ is the total number of samples, and $i$ is the sample index.


### Direct vs. Corrected SNR
A true signal-to-noise ratio compares the average power of a _pure signal_ to that of noise. However, in virtually all marine mammal PAM analyses, calls are extracted from noisy time series and thus actually consist of _signal + noise mixtures_ rather than pure signals. To account for this, the tool returns a _Corrected SNR_ value, which subtracts the estimated average noise power from the average power within the (energy-based) signal window. The effect that this correction has on the results, compared to the direct SNR measurement, is summarized in the table below:

| True Signal vs. Noise Energy | Expected SNR Value<br>(Direct) | Expected SNR Value<br>(Corrected) |
| :--------------------------- | :----------------------------: | :-------------------------------: |
| *Signal Only; Noise Absent*  | +Infinity | +Infinity |
| *Signal > Noise*             | Positive  | Positive  |
| *Signal = Noise*             | Positive  | 0         |
| *Signal < Noise*             | Positive  | Negative  |
| *Signal Absent; Noise Only*  | 0         | -Infinity |







## [OUTDATED] Working outline for SNR functions

### **snr.extractSN**
```matlab
[xSignal, xNoise] = snr.extractSN(x, fs, sigStart, sigStop, noiseDist, clipBufferSize, dFilter, units)
```
**Purpose**
Extract a vector of samples from an acoustic timeseries coresponding to a defined start and stop time. Additionally, extract a vector of samples of the same length some defined distance before the signal of interest, to represent a sample of background noise. The interval seperating the signal samples and the noise samples is user-defined and dependant on the acoustic properties of the signal. Prior to signal and noise extraction, a digital filter (typically a bandpass FIR filter) is applied to a truncated version of the input timeseries. 

**Inputs**
- x = data vector
- fs = sampling rate
- sigStart = signal start seconds or sample
- sigStop = signal stop seconds or sample
- noiseDist = distance from signal from which to sample noise, in seconds or samples
- clipBufferSize = amount of buffer before and after the noise and signal, respectively, to determine the start and end points of the truncated clip that will later be filtered; may be in seconds or samples
- dFilter = filter that will be applied to the truncated clip, in the form of a `digitalFilter` object from the Signal Processing Toolbox
- units = string specifying if start, stop, noise distance, and clip buffer inputs represent seconds or samples

**Outputs**
- xSignal = extracted signal samples
- xNoise = extracted noise samples

### **snr.calculateSNR**
```matlab
[snr_dB] = calculateSNR(xSignal, xNoise)
[snr_dB] = calculateSNR(xSignal, xNoise, 'SubtractNoise',Value)
```
**Purpose**
Calculate the signal to noise ratio given pre-isolated windows of signal and noise. This is implemented as a RMS-based average power calculation.

**Inputs**
- xSignal = signal samples
- xNoise = noise samples
- 'SubtractNoise',Value = optional Name-Value pair that specifies whether or not to subtract noise power from the power derived from the signal input when calculating SNR. Subtracting noise power is meant to provide output that is more aligned with the true definition of SNR when the signal input actually represents a signal + noise mixture (which is almost always the case in any PAM analysis, and always will be the case using this SNR tool). *Value* is either `true` or `false`. The effect that this parameter has on the output SNR value for different levels of noise versus true signal energy is summarized in the table below:

| True Signal vs. Noise Energy | Expected SNR Value with<br>'SubtractNoise' = `false` | Expected SNR Value with<br>'SubtractNoise' = `true` |
| :--------------------------- | :--------------------------------------------------: | :-------------------------------------------------: |
| *Noise Absent; Signal Only*  | +Infinity | +Infinity |
| *Signal > Noise*             | Positive  | Positive  |
| *Signal = Noise*             | Positive  | 0         |
| *Signal < Noise*             | Positive  | Negative  |
| *Signal Absent; Noise Only*  | 0         | -Infinity |

**Outputs**
- snr_dB = Signal to Noise Ratio value (dB)

### **snr.noDelayFilt**
```matlab
[xFilt] = noDelayFilt(dFilter, x)
```
**Purpose**
Filter a signal vector *x* using a `digitalFilter` object from the Signal Processing Toolbox, compensating for group delay introduced by the filter. This function only works if the delay is not frequency-dependent (usually the case with FIR filters). It will generally NOT work with IIR filters like the Butterworth filter - for those types of filters, the best option is to use MATLAB's `filtfilt`.

**Inputs**
- dFilter = filter to apply to the signal, in the form of a `digitalFilter` object from the Signal Processing Toolbox
- x = data vector

**Outputs**
- xFilt = filtered data vector
