# Baleen_SNR_Tool
## Work in progress  
Developed by Wilfried Beslin and Mike Adams  
Maritimes Team Whale
-------------------
Goal: An SNR tool for use in cetacean research

## Introduction
This tool is for use in calculating the signal to noise (SNR) for cetacean vocalizations obtained using JASCO's PAMLAB annotation software.
Initial development was focused on Blue Whale audible calls. The tool currently exists as a helper script<sup>*</sup> with several underlying functions. The helper script (`Baleen_SNR_Tool`) imports the output of JASCO's PAMLAB annotation files, extracts the needed inputs, and then matches the annotated calls to and imports the appropriate .wav files. These inputs are passed to the underlying functions, the first (`snr.extractSN`) to extract the data within the .wav files that corresponds to the annotated call and a sample of noise taken some time before the call. These clippings are bandpassed to the frequencies of interest using a Kaiser window-based FIR filter. Filtering is performed within `snr.extractSN` using the `snr.noDelayFilt` function, which applies the filter such that no time delays are introduced in the output. After bandpass filtering, precise start and end times of the signal are determined based on a user-specified percentage of the energy within the signal window using the function `snr.calcEng`. Noise samples are isolated relative to the energy-based start time of the signal. Ideal duration of the noise window may either be set by the user to some common value (e.g., 10 secs), or be made equal to the signal duration. If a noise window happens to includes parts of other signals that were annotated in PAMLAB, then those parts will be eliminated from the noise window (thereby shortening the noise window). The clipped and bandpassed call and noise samples are then passed to the function `snr.calculateSNR` to calculate the SNR value. The final SNR value is then appended to JASCO's PAMLAB annotation dataframe.

<sup>*</sup>_The helper script is actually implemented as a function that can optionally accept input arguments for greater flexibility. This will be discussed further below_.

## Set up

### Initial Start Up
1) Either clone or download the .zip and unzip the SNR_Tool_Development repository to your local machine.
2) Add this new directory with all of its subfolders to your MATLAB path.
### Requirements

The tool requires inputs to calculate the SNR values. These include:
  -  SNR_PARAMS.csv: a parameter file which contains the filtering and noise presets for each specie's call type. This file has values for:
      - **Species** - The species of interest (e.g. Blue Whale)
      - **Call_Type** - The call type (e.g. Audible, Tonal, etc...) 
      - **Lower_Passband_Frequency** - Lower bound of the bandpass filter before which frequencies become attenuated (Hz). This value should correspond to the lowest frequency of interest.
      - **Upper_Passband_Frequency** - Upper bound of the bandpass filter before which frequencies become attenuated (Hz). This value should correspond to the highest frequency of interest.
      - **Stopband_Rolloff_Bandwidth** - The amount of frequency bandwidth that it takes for the passband frequencies to be attenuated to a level of 60 dB (Hz). The closer this value is to zero, the sharper the passband frequency cutoffs will be, but at the expense of increased filter order (and thus processing time/memory usage). Note that filter order also increases with sampling rate.
      - **Noise_Distance** - Value to determine how far before the ***signal*** the ***noise*** sample will be taken
      - **Ideal_Noise_Duration** - The target duration that the noise window should have (seconds). This parameter can also be left empty, in which case the target noise duration will be equal to the signal duration. Note that the actual noise duration may be shorter than ideal, if the noise window contains other signals that must be removed to avoid contaminated noise estimates.
      - **Signal_Energy_Percent** - The percentage of energy within a signal window that determines the start and stop times of a signal based on cumulative energy. For example, a value of 90 will mark the start time at 5% of the cumulative energy in the window, and the stop time at 95%.
- A directory containing the .csv artefacts output generated by JASCO's PAMLAB. These files contain the artefact output of the manually selected calls. The inputs used from these files are:
  - **Filename** - used to identify the original .wav file containing the call
  - **Relative Start Time** - The manually selected start time in seconds of the call artefact relative to the start of the .wav file
- A directory containing all the .wav files for which PAMLAB artefact .csv files exist. *Note: This directory can contain additional .wav files, but **must** contain all .wav files for which PAMLAB annotations exist*   

## Working outline for SNR functions

### **snr.extractSN**
```matlab
[xSignal, xNoise] = snr.extractSN(x, fs, sigStart, sigStop, noiseDist, clipBufferSize, dFilter, units)
```
**Purpose**
Extract a vector of samples from an acoustic timeseries coresponding to a defined start and stop time. Additionally, extract a vector of samples of the same length some defined distance before the signal of interest, to represent a sample of background noise. The interval seperating the signal samples and the noise samples is user-defined and dependant on the acoustic properties of the signal. Prior to signal and noise extraction, a digital filter (typically a bandpass FIR filter) is applied to a truncated version of the input timeseries. 

**Inputs**
- x = data vector
- fs = sampling rate
- sigStart = signal start seconds or sample
- sigStop = signal stop seconds or sample
- noiseDist = distance from signal from which to sample noise, in seconds or samples
- clipBufferSize = amount of buffer before and after the noise and signal, respectively, to determine the start and end points of the truncated clip that will later be filtered; may be in seconds or samples
- dFilter = filter that will be applied to the truncated clip, in the form of a `digitalFilter` object from the Signal Processing Toolbox
- units = string specifying if start, stop, noise distance, and clip buffer inputs represent seconds or samples

**Outputs**
- xSignal = extracted signal samples
- xNoise = extracted noise samples

### **snr.calculateSNR**
```matlab
[snr_dB] = calculateSNR(xSignal, xNoise)
[snr_dB] = calculateSNR(xSignal, xNoise, 'SubtractNoise',Value)
```
**Purpose**
Calculate the signal to noise ratio given pre-isolated windows of signal and noise. This is implemented as a RMS-based average power calculation.

**Inputs**
- xSignal = signal samples
- xNoise = noise samples
- 'SubtractNoise',Value = optional Name-Value pair that specifies whether or not to subtract noise power from the power derived from the signal input when calculating SNR. Subtracting noise power is meant to provide output that is more aligned with the true definition of SNR when the signal input actually represents a signal + noise mixture (which is almost always the case in any PAM analysis, and always will be the case using this SNR tool). *Value* is either `true` or `false`. The effect that this parameter has on the output SNR value for different levels of noise versus true signal energy is summarized in the table below:

| True Signal vs. Noise Energy | Expected SNR Value with<br>'SubtractNoise' = `false` | Expected SNR Value with<br>'SubtractNoise' = `true` |
| :--------------------------- | :--------------------------------------------------: | :-------------------------------------------------: |
| *Noise Absent; Signal Only*  | +Infinity | +Infinity |
| *Signal > Noise*             | Positive  | Positive  |
| *Signal = Noise*             | Positive  | 0         |
| *Signal < Noise*             | Positive  | Negative  |
| *Signal Absent; Noise Only*  | 0         | -Infinity |

**Outputs**
- snr_dB = Signal to Noise Ratio value (dB)

### **snr.noDelayFilt**
```matlab
[xFilt] = noDelayFilt(dFilter, x)
```
**Purpose**
Filter a signal vector *x* using a `digitalFilter` object from the Signal Processing Toolbox, compensating for group delay introduced by the filter. This function only works if the delay is not frequency-dependent (usually the case with FIR filters). It will generally NOT work with IIR filters like the Butterworth filter - for those types of filters, the best option is to use MATLAB's `filtfilt`.

**Inputs**
- dFilter = filter to apply to the signal, in the form of a `digitalFilter` object from the Signal Processing Toolbox
- x = data vector

**Outputs**
- xFilt = filtered data vector
